# app/routes/web_auth.py
from __future__ import annotations

import hashlib
import os
import secrets
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, Optional

from flask import Blueprint, jsonify, request, g

from app.core.supabase_client import supabase
from app.core.auth import require_auth_plus  # uses web_tokens table validation
from app.core.config import (
    WEB_AUTH_ENABLED,
    WEB_TOKEN_TABLE,
    WEB_TOKEN_PEPPER,
)

bp = Blueprint("web_auth", __name__)


# -----------------------------
# Helpers
# -----------------------------
def _sb():
    return supabase() if callable(supabase) else supabase


def _now_utc() -> datetime:
    return datetime.now(timezone.utc)


def _env(name: str, default: str = "") -> str:
    return (os.getenv(name, default) or default).strip()


WEB_OTP_TABLE = _env("WEB_OTP_TABLE", "web_otps")
WEB_OTP_PEPPER = _env("WEB_OTP_PEPPER", WEB_TOKEN_PEPPER)
WEB_SESSION_TTL_DAYS = int(_env("WEB_SESSION_TTL_DAYS", "30") or "30")
WEB_OTP_TTL_MINUTES = int(_env("WEB_OTP_TTL_MINUTES", "10") or "10")


def _sha256_hex(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8")).hexdigest()


def _otp_hash(contact: str, purpose: str, otp: str) -> str:
    # peppered hash; ties OTP to contact+purpose
    return _sha256_hex(f"{WEB_OTP_PEPPER}:{contact}:{purpose}:{otp}")


def _token_hash(raw_token: str) -> str:
    # MUST match app/core/auth.py
    return _sha256_hex(f"{WEB_TOKEN_PEPPER}:{raw_token}")


def _normalize_contact(v: str) -> str:
    v = (v or "").strip()
    if not v:
        return ""
    # accept +234..., 234..., 0...
    if v.startswith("+"):
        return v
    if v.startswith("234"):
        return "+" + v
    if v.startswith("0"):
        return "+234" + v[1:]
    return v


def _upsert_account_for_contact(contact: str) -> Optional[str]:
    """
    Ensure an account exists for this contact and return account_id.
    Assumes you have an accounts table.
    """
    try:
        # 1) lookup existing
        res = (
            _sb()
            .table("accounts")
            .select("account_id")
            .eq("provider", "web")
            .eq("provider_user_id", contact)
            .limit(1)
            .execute()
        )
        rows = (res.data or []) if hasattr(res, "data") else []
        if rows:
            return rows[0].get("account_id")

        # 2) create new (account_id can be generated by DB trigger/default OR we supply one)
        account_id = secrets.token_hex(16)  # stable string id, easy to store
        ins = (
            _sb()
            .table("accounts")
            .insert(
                {
                    "account_id": account_id,
                    "provider": "web",
                    "provider_user_id": contact,
                    "display_name": contact,
                    "phone": contact,
                }
            )
            .execute()
        )
        _ = ins  # ignore
        return account_id
    except Exception:
        return None


# -----------------------------
# Routes
# -----------------------------
@bp.post("/request-otp")
@bp.post("/web/auth/request-otp")  # supports both (depending how you mount blueprints)
def request_otp():
    if not WEB_AUTH_ENABLED:
        return jsonify({"ok": False, "error": "web_auth_disabled"}), 403

    data: Dict[str, Any] = request.get_json(silent=True) or {}
    contact = _normalize_contact(str(data.get("contact") or ""))
    purpose = (data.get("purpose") or "web_login").strip() or "web_login"

    if not contact:
        return jsonify({"ok": False, "error": "missing_contact"}), 400

    # Create OTP
    # In dev: return dev_otp in response
    env = _env("ENV", "prod").lower()
    otp = "123456" if env == "dev" else f"{secrets.randbelow(1000000):06d}"

    expires_at = _now_utc() + timedelta(minutes=WEB_OTP_TTL_MINUTES)
    otp_hash = _otp_hash(contact, purpose, otp)

    # Store OTP in DB
    try:
        _sb().table(WEB_OTP_TABLE).insert(
            {
                "contact": contact,
                "purpose": purpose,
                "otp_hash": otp_hash,
                "expires_at": expires_at.isoformat().replace("+00:00", "Z"),
                "used": False,
            }
        ).execute()
    except Exception:
        return jsonify({"ok": False, "error": "otp_store_failed"}), 500

    # In prod, you would send SMS here; in dev, show OTP
    resp = {"ok": True, "contact": contact, "purpose": purpose}
    if env == "dev":
        resp["dev_otp"] = otp
    return jsonify(resp)


@bp.post("/verify-otp")
@bp.post("/web/auth/verify-otp")
def verify_otp():
    if not WEB_AUTH_ENABLED:
        return jsonify({"ok": False, "error": "web_auth_disabled"}), 403

    data: Dict[str, Any] = request.get_json(silent=True) or {}
    contact = _normalize_contact(str(data.get("contact") or ""))
    purpose = (data.get("purpose") or "web_login").strip() or "web_login"
    otp = str(data.get("otp") or "").strip()

    if not contact:
        return jsonify({"ok": False, "error": "missing_contact"}), 400
    if not otp:
        return jsonify({"ok": False, "error": "missing_otp"}), 400

    # Validate OTP (latest, not used, not expired)
    try:
        q = (
            _sb()
            .table(WEB_OTP_TABLE)
            .select("id, expires_at, used")
            .eq("contact", contact)
            .eq("purpose", purpose)
            .eq("otp_hash", _otp_hash(contact, purpose, otp))
            .eq("used", False)
            .order("created_at", desc=True)
            .limit(1)
            .execute()
        )
        rows = (q.data or []) if hasattr(q, "data") else []
    except Exception:
        return jsonify({"ok": False, "error": "otp_lookup_failed"}), 500

    if not rows:
        return jsonify({"ok": False, "error": "invalid_otp"}), 401

    row = rows[0]
    # check expiry (parse minimal)
    exp_raw = (row.get("expires_at") or "").replace("Z", "+00:00")
    try:
        exp = datetime.fromisoformat(exp_raw)
    except Exception:
        return jsonify({"ok": False, "error": "otp_expiry_parse_failed"}), 500

    if _now_utc() > exp:
        # mark used best-effort
        try:
            _sb().table(WEB_OTP_TABLE).update({"used": True}).eq("id", row.get("id")).execute()
        except Exception:
            pass
        return jsonify({"ok": False, "error": "otp_expired"}), 401

    # mark OTP as used
    try:
        _sb().table(WEB_OTP_TABLE).update({"used": True}).eq("id", row.get("id")).execute()
    except Exception:
        pass

    # Ensure account exists
    account_id = _upsert_account_for_contact(contact)
    if not account_id:
        return jsonify({"ok": False, "error": "account_create_failed"}), 500

    # Create session token + store session row
    raw_token = secrets.token_hex(32)
    expires_at = _now_utc() + timedelta(days=WEB_SESSION_TTL_DAYS)

    try:
        _sb().table(WEB_TOKEN_TABLE).insert(
            {
                "token_hash": _token_hash(raw_token),
                "account_id": account_id,
                "expires_at": expires_at.isoformat().replace("+00:00", "Z"),
                "revoked": False,
                "last_seen_at": _now_utc().isoformat().replace("+00:00", "Z"),
            }
        ).execute()
    except Exception:
        return jsonify({"ok": False, "error": "session_store_failed"}), 500

    return jsonify(
        {
            "ok": True,
            "mode": "real",
            "token": raw_token,
            "account_id": account_id,
            "expires_at": expires_at.isoformat().replace("+00:00", "Z"),
        }
    )


@bp.get("/me")
@bp.get("/web/auth/me")
@require_auth_plus
def me():
    """
    Now works because require_auth_plus validates against web_tokens table.
    """
    account_id = getattr(g, "account_id", None)
    if not account_id:
        return jsonify({"ok": False, "error": "missing_account"}), 401

    # return minimal profile (extend later)
    try:
        res = (
            _sb()
            .table("accounts")
            .select("account_id, provider, provider_user_id, display_name, phone, created_at")
            .eq("account_id", account_id)
            .limit(1)
            .execute()
        )
        rows = (res.data or []) if hasattr(res, "data") else []
        if not rows:
            return jsonify({"ok": False, "error": "account_not_found"}), 404
        return jsonify({"ok": True, "account": rows[0]})
    except Exception:
        return jsonify({"ok": False, "error": "account_lookup_failed"}), 500
